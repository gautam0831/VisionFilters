# -*- coding: utf-8 -*-
"""Filters.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xVndb8_8ufbXX0KVO7vLpnGFbrXV09AP
"""

import cv2
import numpy as np
from PIL import Image
from scipy.interpolate import UnivariateSpline
from google.colab.patches import cv2_imshow
from google.colab import files

def read_file(filename):
  img = cv2.imread(filename)
  cv2_imshow(img)
  return img

def edge_mask(img, line_size, blur_value):
  gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  gray_blur = cv2.medianBlur(gray, blur_value)
  edges = cv2.adaptiveThreshold(gray_blur, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, line_size, blur_value)
  return edges

def color_quantization(img, k):
# Transform the image
  data = np.float32(img).reshape((-1, 3))

# Determine criteria
  criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 20, 0.001)

# Implementing K-Means
  ret, label, center = cv2.kmeans(data, k, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
  center = np.uint8(center)
  result = center[label.flatten()]
  result = result.reshape(img.shape)
  return result

def cartoonize():
  uploaded = files.upload()
  filename = next(iter(uploaded))
  img = read_file(filename)

  #Apply edge mask 
  line_size = 7
  blur_value = 7
  edges = edge_mask(img, line_size, blur_value)

  #Quantize colors
  total_color = 9
  img = color_quantization(img, total_color)
  #Blur image
  blurred = cv2.bilateralFilter(img, d=7, sigmaColor=200,sigmaSpace=200)
  #Cartoonize
  cartoon = cv2.bitwise_and(blurred, blurred, mask=edges)
  cv2_imshow(cartoon)

def sepia():
  uploaded = files.upload()
  filename = next(iter(uploaded))
  img = Image.open(filename)
  img.show()
  # gray_img = img.convert("L")
  # gray_img.show()
  # #Create new image with sepia tone
  # sepia_image = Image.new("RGB", gray_img.size)
  w, h = img.size

  #Apply sepia tone to each pixel of the new image
  for x in range(w):
    for y in range(h):
      r, g, b = img.getpixel((x, y))
      tr = int(0.393 * r + 0.769 * g + 0.189 * b)
      tg = int(0.349 * r + 0.686 * g + 0.168 * b)
      tb = int(0.272 * r + 0.534 * g + 0.131 * b)
      if tr > 255:
        tr = 255

      if tg > 255:
        tg = 255

      if tb > 255:
          tb = 255

      img.putpixel((x, y), (tr, tg, tb))

  
  img.save("sepia_"+filename)

def spreadLookupTable(x,y):
  spline = UnivariateSpline(x,y)
  return spline(range(256))

def make_cold(I):
  increaseLookupTable = spreadLookupTable([0, 64, 128, 256], [0, 80, 160, 256])
  decreaseLookupTable = spreadLookupTable([0, 64, 128, 256], [0, 50, 100, 256])
  red, green, blue = cv2.split(I)
  red = cv2.LUT(red, increaseLookupTable).astype(np.uint8)
  blue = cv2.LUT(blue, decreaseLookupTable).astype(np.uint8)
  return cv2.merge((red, green, blue))

def artify():
  uploaded = files.upload()
  filename = next(iter(uploaded))
  I = read_file(filename)

  G = cv2.cvtColor(I, cv2.COLOR_BGR2GRAY)
  G = cv2.GaussianBlur(G, (3,3), 3.14)
  G = cv2.medianBlur(G, 11)
  G = cv2.adaptiveThreshold(G, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 11)

  C = cv2.bilateralFilter(I, 7, 200, 200)
  A = cv2.bitwise_and(C, C, mask=G)

  E = cv2.Canny(C, 50, 200)
  E[E==255] = 1
  E[E==0] = 255
  E[E==1] = 0
  E = cv2.cvtColor(E, cv2.COLOR_GRAY2BGR)

  alpha = 0.25
  A = cv2.addWeighted(E, alpha, A, 1-alpha, 0)

  # alpha = 0.5
  # A = cv2.addWeighted(E, alpha, A, 1-alpha, 0)

  A = make_cold(A)
  cv2_imshow(A)